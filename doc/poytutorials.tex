These tutorials are intended for new \poy users as well as for users who 
have previously used \texttt{POY3} and are now upgrading to \poy. The command structure 
has been overhauled in \poy to allow greater user control. Although \texttt{POY3} users 
will find the changes challenging initially (as did we), the new structure is 
more intuitive, flexible, and powerful. For details, see the \poy Commands 
Reference; for a quick overview see the \poy Quick Guide. The following 
tutorials are intended to facilitate the transition to the new command structure 
by providing examples of analyses that are loosely based on the commands covered 
in the tutorials found in Chapter 14 in Wheeler et al. (2006). For a fuller 
discussion of analytical strategies, refer to:\
\begin{center}
http://homepage.mac.com/wmleosmith/homepage/datafiles/joy/joy.html
\end{center}
and Chapter 9 
in Wheeler et al. (2006). In addition to the \poy executable, the only other 
application software you need for these tutorials is a text editor, such as 
Textpad, BBEDIT, EMACS, Word, WordPad, or NotePad. Additionally, a postscript 
(.ps) viewer/converter (e.g., online at http://pdf.sesse.net/ , Adobe Acrobat 
Distiller, Apple Preview) will be required to view publication-quality 
postscript cladograms.

The commands in the following tutorials can all be written and executed 
separately from the command line, saved and run as a script file, or written 
into a text file and copied and pasted into \poy's interactive console or flat 
interface. Initially, we recommend writing and executing them separately, as 
presented below, as this will allow you to see how \poy reports progress as you 
start to use \poy. We also recommend running these tutorials using the graphical 
interface (ncurses version) of \poy, although they can also be run using the 
flat interface.

Preliminary tasks:
\begin{enumerate}
    \item Make sure you have downloaded all of the \poy tutorial datafiles. 
    \item Create a folder named \texttt{tutorial}. Although you can place this folder anywhere, we suggest you make it a 
        subfolder to the \poy folder you created during installation. In addition, nothing depends operationally on this new folder being 
        named \texttt{tutorial}. 
    \item Review the \poy Quick Guide for instructions to install and run \poy using 
        Windows, Mac OSX, and Linux operating systems. 
    \item Either copy the \poy executable from the \poy folder to the new
        \texttt{tutorial}
        folder or make sure the executable is in /usr/local/bin/ or another directory 
        included in your path (Linux and Mac OSX only). 
    \item Copy all of the files from the \poy \texttt{tutorial} folder to the new
        \texttt{tutorial} 
        folder. 
\end{enumerate}

\section{Basic Search}{\label{tutorial2}}

This tutorial illustrates the basics of running \poy using single input datafile. 
\begin{enumerate}
\item Navigate to the \texttt{tutorial} folder. 
\item Launch \poy (review \poy Quick Guide for instructions for your platform).
\item Type:

    \begin{verbatim}
    read ("mol1.txt") [enter]
    build (100) [enter]
    select (unique) [enter]
    swap (threshold:10) [enter]
    select () [enter]
    report (asciitrees) [enter]
    report ("tutorial1_trees.txt", trees) [enter]
    report ("tutorial1_stats.txt", treestats) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
\item  Import the DNA sequence datafile mol1.txt.
\item  Generate 100 random addition sequence Wagner trees.
\item  Discard duplicate trees.
\item  Alternate SPR and TBR branch swapping of all current trees as well as all 
new trees found that are up to 10\%
longer than the current tree being 
swapped. Note: Threshold during swapping is equivalent to slop in \texttt{POY3}. 
Given the faster algorithms and better heuristics of \poy it is likely to 
be less important than it was in \texttt{POY3}.
\item  Discard suboptimal and duplicate trees (i.e., retain only optimal trees).
\item  Draw optimal trees in \poy Output window (ncurses version only) or output 
file (non-ncurses version), reporting the cost of each tree.
\item  Output all current trees to file tutorial1\_trees.txt.
\item  Output basic tree statistics to file tutorial1\_stats.txt.
\end{itemize}

\item View cladogram(s) in parenthetical format by opening tutorial1\_trees.txt in 
your chosen text editor.
\item View basic tree statistics by opening tutorial1\_stats.txt in your chosen 
text editor.
\end{enumerate}

\section[Advanced Search]{Advanced Search I: Multiple Datasets and Data Types, Equal 
Weighting, Rooting, and Publication Quality Trees}{\label{tutorial2}}

This tutorial builds on Tutorial~\ref{tutorial1} to include multiple input datafiles and 
multiple data types (i.e., genotypic and phenotypic) using equal weighting, 
designate the root, and automatically generate publication quality trees.

\begin{enumerate}
\item Type: 

\begin{verbatim}
    read ("mol2.txt", "morph.txt") [enter]
    set (root: "Hagfish") [enter]
    transform ((all, tcm:(1,1))) [enter]
    build (100) [enter]
    select (unique) [enter]
    swap (threshold:10) [enter]
    select () [enter]
    report ("tutorial2", graphtrees) [enter]
    report ("tutorial2_trees.txt", trees) [enter]
    report ("tutorial2_stats.txt", treestats) [enter]
\end{verbatim}

The above commands will perform the following tasks using default parameters:

\begin{itemize}
\item Import the DNA sequence datafile mol2.txt and the phenotypic datafile 
morph.ss. 
\item Designate the Hagfish as the root. 
\item Set indel and substitution costs to 1 (equal weighting). The additivity 
(ordering) of the phenotypic characters is determined in the ccode of the 
NONA file morph.ss. By default, the transformation cost for phenotypic 
characters is 1.  
\item Generate 100 random addition sequence Wagner trees.
\item Discard duplicate trees.
\item For each tree in memory, alternate SPR and TBR branch swapping of the tree 
and all trees found within 10\% of the cost of the tree.
\item Discard suboptimal and duplicate trees (\emph{i.e.}, retain only optimal trees).
\item Output publication-quality cladogram(s) of optimal tree(s) to a postscript 
file tutorial2.ps. (Note: \poy automatically adds the \texttt{.ps} extension.)  
\item Output all current trees to file tutorial2\_trees.txt.
\item Output basic tree statistics to file tutorial2\_stats.txt.
\end{itemize}

\item View publication-quality cladogram(s) by opening tutorial2.ps in your chosen 
postscript viewer.
\item View cladogram(s) in parenthetical format by opening tutorial2\_trees.txt in 
your chosen text editor.
\item View basic tree statistics by opening tutorial2\_stats.txt in your chosen 
text editor.

\end{enumerate}

\section[Fusing and Ratcheting]{Advanced Search II: Tree Fusing and Fragment
Ratcheting}{\label{tutorial3}}

This tutorial builds on Tutorial~\ref{tutorial2} to use tree fusing and fragment ratcheting 
that help to escape suboptimal islands. This tutorial also introduces matrix and 
tree output in NONA format.

\begin{enumerate}
\item Type: 
\begin{verbatim}
    build (100) [enter]
    select (unique) [enter]
    fuse () [enter]
    select () [enter]
    perturb (iterations:10, ratchet:(0.2,5)) [enter]
    select () [enter]
    swap (threshold:10) [enter]
    select () [enter]
    report ("tutorial3", graphtrees) [enter]
    report ("alignment3.ss", phastwinclad) [enter]
\end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
\item Generate 100 random addition sequence Wagner trees.
\item Discard duplicate trees.
\item Perform cladogram searching by fusing one pair of trees in memory. Note: Tree 
fusing requires at least two trees; if there was only one tree in memory, 
an error message will be generated. 
\item Discard suboptimal and duplicate trees (\emph{i.e.}, retain only optimal trees).
\item Perform 10 successive repetitions of a fragment-based ratchet by randomly 
selecting 20\% of the fragments and upweighting them by a factor of five.
\item Discard suboptimal and duplicate trees (i.e., retain only optimal trees).
\item For each tree in memory, alternate SPR and TBR branch swapping of the tree 
and all trees found within 10\% of the cost of the tree.
\item Discard suboptimal and duplicate trees (\emph{i.e.}, retain only optimal trees).
\item Output publication-quality cladogram(s) of optimal tree(s) to a postscript 
file tutorial3.ps. (Note: \poy automatically adds the \texttt{.ps} extension.)
\item Output NONA file with the implied alignment for one (if multiple) optimal 
trees and all optimal trees in the file alignment3.ss.
\end{itemize}

\item View publication-quality cladogram(s) by opening tutorial3.ps in your chosen 
postscript viewer.
\item View implied alignment, optimal tree(s), and manipulate data by opening the 
file alignment3.ss in WinClada or MacClade.

\end{enumerate}

\section[Trees and Step Matrices]{Advanced Search III: Input Trees and Step
Matrices}{\label{tutorial4}}

This tutorial builds on Tutorials~\ref{tutorial2} and~\ref{tutorial3}, and introduces the use of input trees 
and complex differential cost step matrices.

\begin{enumerate}
\item Type: 
    \begin{verbatim}
    read ("trees.txt") [enter]
    transform ((all, tcm:"g4ts1tv2.txt"), 
    (static, weightfactor:4)) [enter]
    swap (threshold:10) [enter]
    select () [enter]
    report ("tutorial5", graphtrees) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
\item Read cladograms from the input file trees.txt.
\item Apply specified transformation costs to data. The transformation cost 
matrix in the file g4ts1tv2.txt is applied to the dynamic homology 
characters (i.e., unaligned DNA sequences) to assign indel events a cost 
of 4, transitions 1, and transversions 2. All static homology characters 
(i.e., the phenotypic characters in the file morph.txt) are upweighted by 
a factor of 4, with additivities and previous relative weights unchanged 
(e.g., a character with transformations costs of 2 would be now have a 
transformation cost of 8).
\item For each tree in memory, alternate SPR and TBR branch swapping of the tree 
and all trees found within 10\% of the cost of the tree.
\item Discard suboptimal and duplicate trees (i.e., retain all most optimal 
trees).
\item Output publication-quality cladogram(s) of optimal tree(s) to a postscript 
file tutorial5.ps. (Note: \poy automatically adds the .ps extension.)  
\end{itemize}

\item View publication-quality cladogram(s) by opening tutorial4.ps in your chosen 
postscript viewer.
\item View cladogram(s) in parenthetical format by opening tutorial4\_trees.txt in 
your chosen text editor.
\item View basic tree statistics by opening tutorial4\_stats.txt in your chosen 
text editor.
\end{enumerate}

\section[Bremer Support]{Support I: Bremer Support}

This tutorial builds on the previous tutorials to illustrate Bremer support 
calculation.
\begin{enumerate}
\item Type: 
    \begin{verbatim}
    transform ((all, tcm:(1,1)), (static, weightfactor:1)) [enter]
    swap () [enter]
    calculate_support (bremer, build (trees:5), swap (trees:2)) [enter]
    report (supports) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\item Apply a weight of one to all transformations.
\item For each tree in memory, alternate SPR and TBR branch swapping of the 
optimal tree(s).
\item Estimate Bremer support by using inverse constraints, doing five 
independent searches for every group, holding a maximum of two trees. 
\item Output support values for each group in parenthetical notation to \poy 
output window.

\end{enumerate}

\section[Bootstrap Support]{Support II: Bootstrap Support Using Dynamic Homology}

This tutorial builds on the previous tutorials to illustrate the calculation of 
bootstrap frequencies. As discussed in the \poy Commands Reference, the 
characters sampled during pseudoreplicates are entire fragments of DNA 
sequences, not individual nucleotide characters. Tutorial 7 shows how to 
estimate bootstrap frequencies using static homology, which allows nucleotide-
level characters to be sampled. 

\begin{enumerate}
\item Type:
    \begin{verbatim}
    calculate_support (bootstrap: 100, build(trees:2), 
    swap(trees:1)) [enter]
    report (supports) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
\item Perform 100 pseudoreplicates by sampling characters with replacement, 
doing two independent searches for each pseudoreplicate and holding a 
maximum of one tree. 
\item Output bootstrap frequencies for each group in parenthetical notation to 
\poy output window.
\end{itemize}
\end{enumerate}

\section[Bootstrap Support with Static Homologies]{Support III: Bootstrap Support Using Static Homology}

This tutorial builds on the previous tutorials to illustrate the calculation of 
bootstrap frequencies. Here, bootstrap frequencies are obtained from analysis of 
the implied alignment of static homologies, which permits individual nucleotide-
level characters to be sampled instead of whole fragments, as is done using 
dynamic homology. 
\begin{enumerate}
\item Type:
    \begin{verbatim}
    transform ((all, static_approx)) [enter]
    calculate_support (bootstrap: 100, build(trees:2), 
    swap(trees:1)) [enter]
    report (supports) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
\item Generate the alignment implied by the optimal tree and given the assumed 
transformation costs. 
\item Perform 100 pseudoreplicates by sampling characters with replacement, 
doing two independent searches for each pseudoreplicate and holding a 
maximum of one tree. 
\item Output bootstrap frequencies for each group in parenthetical notation to 
\poy output window.
\end{itemize}
\end{enumerate}

\section[Chromosome Analysis]{Chromosome Analysis I: Unannotated Sequences}

This tutorial illustrates the analysis of chromosome-level transformations using 
unannotated sequences, i.e., contiguous strings of sequences without prior 
identification of independent regions.
\begin{enumerate}
    \item Type
    \begin{verbatim}
    wipe () [enter]
    read (chromosome:("mit5.txt"))  [enter]
    transform ((all, dynamic_pam:(inversion:15, locus_indel:(10, 1.5), 
    median:  3, swap_med:5, circular:true, approx:true))) [enter]
    build (5) [enter]
    swap ()[enter]
    select () [enter]
    report (asciitrees, diagnosis) [enter]
    transform ((all, dynamic_pam:(inversion:15, locus_indel:(10, 1.5), 
    median:3, swap_med:5, circular:true, approx:false))) [enter]
    swap ()[enter]
    select ()[enter]
    report (asciitrees, diagnosis) [enter]
    \end{verbatim}

The above commands will perform the following tasks using default parameters:
\begin{itemize}
    \item Clear all data and trees from memory.
    \item Import datafile mit5.txt.
    \item Treat all data as pertaining to unannotated chromosome data, setting the 
        following parameters: inversion distance and cost 15, locus indel 10 + 1.5 
        times the length (number of nucleotides) of the locus, keep three 
        candidate medians, swap on medians for 5 rounds, treat as circular 
        chromosome, and use fixed-states optimization to approximate chromosome 
        medians.
    \item Generate 5 random addition sequence Wagner trees.
    \item Alternate SPR and TBR branch swapping of each tree in memory.
    \item Discard suboptimal and duplicate trees (i.e., retain only optimal trees).
    \item Draw optimal trees in \poy Output window (ncurses version only) or output 
        file (non-ncurses version), reporting the cost of each tree.
    \item Output the optimal median states and edge costs.
    \item Treat all data as pertaining to unannotated chromosome data with 
        parameters as above but using optimization alignment (not fixed-states) to 
        approximate chromosome medians.   
    \item Alternate SPR and TBR branch swapping of each tree in memory.
    \item Draw optimal trees in \poy Output window (ncurses version only) or output 
        file (non-ncurses version), reporting the cost of each tree.
    \item Output optimal median states and edge costs.
\end{itemize}
\end{enumerate}
